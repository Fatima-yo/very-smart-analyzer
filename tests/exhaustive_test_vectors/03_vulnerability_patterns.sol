// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";

/**
 * Vulnerability Patterns Test Contract
 * Covers: Missing protections, weak validation, unsafe patterns
 * All functions are intentionally vulnerable for testing
 */

contract VulnerabilityPatterns is EIP712 {
    using ECDSA for bytes32;

    mapping(bytes32 => bool) public usedHashes;
    mapping(address => uint256) public nonces;

    struct Permit {
        address owner;
        address spender;
        uint256 value;
        uint256 nonce;
        uint256 deadline;
    }

    struct WeakPermit {
        address owner;
        address spender;
        uint256 value;
        // Missing nonce and deadline
    }

    struct UnsafePermit {
        address owner;
        address spender;
        uint256 value;
        uint256 nonce;
        uint256 deadline;
        uint256 chainId;
        uint256 version;
    }

    bytes32 public constant PERMIT_TYPEHASH = keccak256(
        "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
    );

    bytes32 public constant WEAK_PERMIT_TYPEHASH = keccak256(
        "WeakPermit(address owner,address spender,uint256 value)"
    );

    bytes32 public constant UNSAFE_PERMIT_TYPEHASH = keccak256(
        "UnsafePermit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline,uint256 chainId,uint256 version)"
    );

    constructor() EIP712("VulnerabilityPatterns", "1") {}

    // ===== VULNERABILITY 1: MISSING NONCE PROTECTION =====
    
    function vulnerableNoNonce(
        address spender,
        uint256 amount,
        bytes memory signature
    ) external {
        // VULNERABLE: No nonce check - replay attack possible
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // No replay protection - signature can be used multiple times
    }

    function vulnerableNoNonceEIP712(
        WeakPermit memory permit,
        bytes memory signature
    ) external {
        // VULNERABLE: No nonce in struct - replay attack possible
        bytes32 structHash = keccak256(
            abi.encode(WEAK_PERMIT_TYPEHASH, permit.owner, permit.spender, permit.value)
        );
        bytes32 hash = _hashTypedDataV4(structHash);
        
        address signer = hash.recover(signature);
        require(signer == permit.owner, "Invalid signature");
        // No nonce validation - vulnerable to replay
    }

    // ===== VULNERABILITY 2: MISSING DEADLINE PROTECTION =====
    
    function vulnerableNoDeadline(
        address spender,
        uint256 amount,
        bytes memory signature
    ) external {
        // VULNERABLE: No deadline check - signature never expires
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // No deadline validation - signature is valid forever
    }

    function vulnerableNoDeadlineEIP712(
        WeakPermit memory permit,
        bytes memory signature
    ) external {
        // VULNERABLE: No deadline in struct - signature never expires
        bytes32 structHash = keccak256(
            abi.encode(WEAK_PERMIT_TYPEHASH, permit.owner, permit.spender, permit.value)
        );
        bytes32 hash = _hashTypedDataV4(structHash);
        
        address signer = hash.recover(signature);
        require(signer == permit.owner, "Invalid signature");
        // No deadline validation - vulnerable to indefinite use
    }

    // ===== VULNERABILITY 3: MISSING TIMESTAMP PROTECTION =====
    
    function vulnerableNoTimestamp(
        address spender,
        uint256 amount,
        bytes memory signature
    ) external {
        // VULNERABLE: No timestamp validation
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // No timestamp check - no time-based validation
    }

    // ===== VULNERABILITY 4: MISSING CHAIN ID PROTECTION =====
    
    function vulnerableNoChainId(
        address spender,
        uint256 amount,
        bytes memory signature
    ) external {
        // VULNERABLE: No chain ID validation - cross-chain replay possible
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // No chain ID check - vulnerable to cross-chain replay
    }

    function vulnerableNoChainIdEIP712(
        Permit memory permit,
        bytes memory signature
    ) external {
        // VULNERABLE: No chain ID in domain separator
        require(permit.deadline >= block.timestamp, "Permit expired");
        
        bytes32 structHash = keccak256(
            abi.encode(PERMIT_TYPEHASH, permit.owner, permit.spender, permit.value, nonces[permit.owner]++, permit.deadline)
        );
        bytes32 hash = _hashTypedDataV4(structHash);
        
        address signer = hash.recover(signature);
        require(signer == permit.owner, "Invalid signature");
        // No chain ID validation - cross-chain replay possible
    }

    // ===== VULNERABILITY 5: MISSING DOMAIN SEPARATOR =====
    
    function vulnerableNoDomainSeparator(
        address spender,
        uint256 amount,
        bytes memory signature
    ) external {
        // VULNERABLE: No domain separator - cross-contract replay possible
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // No domain separator - vulnerable to cross-contract replay
    }

    // ===== VULNERABILITY 6: WEAK SIGNER VALIDATION =====
    
    function vulnerableWeakSignerValidation(
        address spender,
        uint256 amount,
        bytes memory signature
    ) external {
        // VULNERABLE: Weak signer validation
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // No signer validation - any valid signature is accepted
    }

    function vulnerableNoSignerCheck(
        address spender,
        uint256 amount,
        address expectedSigner,
        bytes memory signature
    ) external {
        // VULNERABLE: No signer validation against expected signer
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // Missing: require(signer == expectedSigner, "Invalid signer");
    }

    // ===== VULNERABILITY 7: UNSAFE SIGNATURE RECOVERY =====
    
    function vulnerableUnsafeRecovery(
        address spender,
        uint256 amount,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // VULNERABLE: Using ecrecover without validation
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ecrecover(ethSignedMessageHash, v, r, s);
        
        // No validation of v, r, s values - vulnerable to malleability
    }

    function vulnerableNoMalleabilityCheck(
        address spender,
        uint256 amount,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // VULNERABLE: No malleability protection
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ecrecover(ethSignedMessageHash, v, r, s);
        
        // Missing: require(signer != address(0), "Invalid signature");
        // Missing: require(v == 27 || v == 28, "Invalid v value");
    }

    // ===== VULNERABILITY 8: MISSING VERSION FIELD =====
    
    function vulnerableNoVersion(
        Permit memory permit,
        bytes memory signature
    ) external {
        // VULNERABLE: EIP712 without version field
        require(permit.deadline >= block.timestamp, "Permit expired");
        
        bytes32 structHash = keccak256(
            abi.encode(PERMIT_TYPEHASH, permit.owner, permit.spender, permit.value, nonces[permit.owner]++, permit.deadline)
        );
        bytes32 hash = _hashTypedDataV4(structHash);
        
        address signer = hash.recover(signature);
        require(signer == permit.owner, "Invalid signature");
        // No version field in domain - potential compatibility issues
    }

    // ===== VULNERABILITY 9: INSUFFICIENT ENTROPY =====
    
    function vulnerableInsufficientEntropy(
        address spender,
        uint256 amount,
        uint256 weakSalt,
        bytes memory signature
    ) external {
        // VULNERABLE: Weak salt/entropy
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount, weakSalt));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // Weak salt - predictable and guessable
    }

    function vulnerablePredictableNonce(
        address spender,
        uint256 amount,
        bytes memory signature
    ) external {
        // VULNERABLE: Predictable nonce
        uint256 predictableNonce = block.timestamp; // Predictable!
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount, predictableNonce));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // Predictable nonce - vulnerable to precomputation attacks
    }

    // ===== VULNERABILITY 10: NO THRESHOLD CHECK =====
    
    function vulnerableNoThresholdCheck(
        address[] memory signers,
        bytes[] memory signatures,
        address spender,
        uint256 amount
    ) external {
        // VULNERABLE: Multi-sig without threshold validation
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        
        for (uint i = 0; i < signatures.length; i++) {
            address signer = ethSignedMessageHash.recover(signatures[i]);
            // No threshold check - any number of signatures accepted
        }
    }

    // ===== VULNERABILITY 11: MULTIPLE VULNERABILITIES COMBINED =====
    
    function vulnerableMultipleIssues(
        address spender,
        uint256 amount,
        bytes memory signature
    ) external {
        // VULNERABLE: Multiple security issues combined
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // Missing: nonce check
        // Missing: deadline check
        // Missing: timestamp check
        // Missing: chain ID check
        // Missing: domain separator
        // Missing: signer validation
        // Missing: malleability check
    }

    // ===== VULNERABILITY 12: UNSAFE EIP712 IMPLEMENTATION =====
    
    function vulnerableUnsafeEIP712(
        UnsafePermit memory permit,
        bytes memory signature
    ) external {
        // VULNERABLE: Unsafe EIP712 implementation
        bytes32 structHash = keccak256(
            abi.encode(UNSAFE_PERMIT_TYPEHASH, permit.owner, permit.spender, permit.value, permit.nonce, permit.deadline, permit.chainId, permit.version)
        );
        bytes32 hash = _hashTypedDataV4(structHash);
        
        address signer = hash.recover(signature);
        require(signer == permit.owner, "Invalid signature");
        
        // Missing: deadline check
        // Missing: nonce validation
        // Missing: chain ID validation
        // Missing: version validation
    }

    // ===== VULNERABILITY 13: REENTRANCY IN SIGNATURE VALIDATION =====
    
    mapping(address => bool) public processedSignatures;
    
    function vulnerableReentrancy(
        address spender,
        uint256 amount,
        bytes memory signature
    ) external {
        // VULNERABLE: Reentrancy in signature processing
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // State change before external call (if any)
        processedSignatures[signer] = true;
        
        // External call could reenter this function
        // Missing: reentrancy guard
    }

    // ===== VULNERABILITY 14: TIMESTAMP MANIPULATION =====
    
    function vulnerableTimestampManipulation(
        address spender,
        uint256 amount,
        uint256 userTimestamp,
        bytes memory signature
    ) external {
        // VULNERABLE: User-controlled timestamp
        require(userTimestamp >= block.timestamp, "Timestamp expired");
        
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount, userTimestamp));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // User can manipulate timestamp - no server-side validation
    }

    // ===== VULNERABILITY 15: SIGNATURE REPLAY ACROSS FUNCTIONS =====
    
    function vulnerableCrossFunctionReplay(
        address spender,
        uint256 amount,
        bytes memory signature
    ) external {
        // VULNERABLE: Same signature can be used across different functions
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // No function-specific domain separator
    }

    function vulnerableCrossFunctionReplay2(
        address spender,
        uint256 amount,
        bytes memory signature
    ) external {
        // VULNERABLE: Same signature can be used in this function too
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // Same message hash as vulnerableCrossFunctionReplay - replay possible
    }
} 