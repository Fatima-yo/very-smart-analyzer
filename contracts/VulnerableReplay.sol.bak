// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract VulnerableReplay {
    using ECDSA for bytes32;
    
    mapping(address => uint256) public balances;
    mapping(address => uint256) public nonces;

    struct Permit {
        address owner;
        address spender;
        uint256 value;
        uint256 nonce;
        uint256 deadline;
    }

    // VULNERABLE: No nonce check - replay attack possible
    function deposit(address to, uint256 amount, bytes memory signature) public {
        bytes32 messageHash = keccak256(abi.encodePacked(to, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        require(signer == to, "Invalid signature");
        balances[to] += amount;
        // Missing: nonces[signer]++ or replay protection
    }

    // VULNERABLE: Missing deadline check
    function permit(Permit memory permitData, bytes memory signature) public {
        bytes32 structHash = keccak256(
            abi.encode(permitData.owner, permitData.spender, permitData.value, permitData.nonce, permitData.deadline)
        );
        bytes32 ethSignedMessageHash = structHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        require(signer == permitData.owner, "Invalid signature");
        require(permitData.nonce == nonces[permitData.owner], "Invalid nonce");
        nonces[permitData.owner]++;
        
        // Missing: require(permitData.deadline >= block.timestamp, "Permit expired");
    }

    // VULNERABLE: Weak signer validation
    function approve(address spender, uint256 amount, bytes memory signature) public {
        bytes32 messageHash = keccak256(abi.encodePacked(spender, amount));
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // Missing: require(signer != address(0), "Invalid signer");
        // Missing: require(signer == msg.sender, "Invalid signer");
        
        // No validation at all - any valid signature works
    }

    // Basic signature verification function for testing
    function verifySignature(bytes32 messageHash, bytes memory signature) public pure returns (address) {
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        return ethSignedMessageHash.recover(signature);
    }

    // Function to execute with signature (for replay attack testing)
    function executeWithSignature(bytes32 messageHash, bytes memory signature, uint256 nonce) public {
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        require(signer != address(0), "Invalid signer");
        // Missing nonce check - vulnerable to replay attacks
    }

    // Function to execute with deadline (for timing attack testing)
    function executeWithDeadline(bytes32 messageHash, bytes memory signature, uint256 deadline) public {
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        require(signer != address(0), "Invalid signer");
        // Missing deadline check - vulnerable to timing attacks
    }

    // Function to execute with nonce (for entropy attack testing)
    function executeWithNonce(bytes32 messageHash, bytes memory signature, uint256 nonce) public {
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        require(signer != address(0), "Invalid signer");
        // Missing nonce validation - vulnerable to entropy attacks
    }

    // Function to execute with chain ID (for cross-chain attack testing)
    function executeWithChainId(bytes32 messageHash, bytes memory signature, uint256 chainId) public {
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        require(signer != address(0), "Invalid signer");
        // Missing chain ID validation - vulnerable to cross-chain attacks
    }

    // Function to execute with amount (for edge case testing)
    function executeWithAmount(bytes32 messageHash, bytes memory signature, uint256 amount) public {
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        require(signer != address(0), "Invalid signer");
        // Missing amount validation - vulnerable to edge cases
    }

    // Function to execute multi-sig (for multi-sig attack testing)
    function executeMultiSig(bytes32 messageHash, bytes[] memory signatures, uint256 requiredSignatures) public {
        require(signatures.length >= requiredSignatures, "Insufficient signatures");
        
        address[] memory signers = new address[](signatures.length);
        for (uint256 i = 0; i < signatures.length; i++) {
            bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
            signers[i] = ethSignedMessageHash.recover(signatures[i]);
            require(signers[i] != address(0), "Invalid signer");
        }
        
        // Missing duplicate signature check - vulnerable to multi-sig attacks
    }

    // Function to verify EIP712 signature (for format validation testing)
    function verifyEIP712Signature(bytes memory structData) public pure returns (address) {
        // This is a simplified version - in real implementation would use EIP712
        bytes32 hash = keccak256(structData);
        return address(0); // Placeholder
    }
} 