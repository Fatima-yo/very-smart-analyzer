You are helping build a smart fuzz-testing tool for Ethereum smart contracts. 
This tool analyzes how contracts verify off-chain signatures to extract function definitions for test generation.

Your task is to analyze a Solidity smart contract and return a JSON object that describes every function that accepts or verifies an off-chain signature.

IMPORTANT: Do NOT perform any security analysis or vulnerability detection. Your job is ONLY to extract function definitions and signature patterns. Security analysis will be performed by the Go code.

CRITICAL: You MUST return valid JSON. Do not include any explanations, comments, or markdown formatting around the JSON.

General Rules:
For each function that verifies a signature:

Return functionName and functionSelector (full Solidity signature)

Specify signatureType.kind (one of: "EIP712", "ETH_SIGN", "EIP191_PERSONAL_SIGN", "EIP2612", "EIP1271", "CUSTOM")

Use "signature", "v", "r", "s" arrays — always arrays, even for single values

Omit any field not used

Function Context:
"visibility": one of "public", "external", "internal", "private"
"stateMutability": one of "pure", "view", "payable", "nonpayable"
"accessControl": array of modifiers (e.g., ["onlyOwner", "whenNotPaused"])

Signature Inputs (actual signature data):
Use the following keys if relevant: "signature", "v", "r", "s"

Each is an array of objects with:

source: one of "parameter", "structField", "arrayElement", "mappingKey", "mappingValue"

solType: Solidity type (bytes, uint8, bytes32, etc.)

signerRole: optional (e.g., "user", "validator", "relayer", "owner", "guardian")

parentStruct: required if source is "structField"

arrayIndex: required if source is "arrayElement"

mappingKey: required if source is "mappingKey" or "mappingValue"

Signature Fields (the signed message structure):
"signatureFields":

structured: true if passed as a struct

structName: required if structured

fields: array of { name, solType, isNested, nestedStructName }

isNested: true if field is a nested struct

nestedStructName: required if isNested is true

Signature Control Fields (security-critical fields):
These are fields that may or may not appear in the contract. Return them only if found, otherwise omit:

"nonce": { name, solType, source, validationType }
"timestamp": { name, solType, source, validationType }
"deadline": { name, solType, source, validationType }
"chainId": { name, solType, source, validationType }
"version": { name, solType, source, validationType }
"domainSeparator": { name, solType, source, validationType }
"salt": { name, solType, source, validationType }

source: one of "parameter", "structField", "arrayElement", "stateVariable", "constant"
validationType: one of "explicit", "implicit", "none", "missing"

Signature Complexity (structural information):
"signatureComplexity": {
  "hasNestedStructs": boolean,
  "hasArrays": boolean,
  "hasMappings": boolean,
  "structDepth": number,
  "arrayLength": number,
  "totalFields": number
}

✅ Do not return nulls.
✅ Do not return explanations.
✅ Do not return comments.
✅ Only return valid JSON.
✅ Do NOT perform security analysis or vulnerability detection.
✅ Focus ONLY on extracting function definitions and signature patterns.
✅ Be thorough in extracting all signature-related function details.
✅ If no signature functions are found, return an empty array for signatureFunctions.

Solidity input:

