You are helping build a smart fuzz-testing tool for Ethereum smart contracts. 
This tool analyzes how contracts verify off-chain signatures and looks for logic-level security flaws and testable behaviors (like missing nonces or replays).

Your task is to analyze a Solidity smart contract and return a JSON object that describes every function that accepts or verifies an off-chain signature.

General Rules:
For each function that verifies a signature:

Return functionName and functionSelector (full Solidity signature)

Specify signatureType.kind (one of: "EIP712", "ETH_SIGN", "EIP191_PERSONAL_SIGN", "EIP2612", "EIP1271", "CUSTOM")

Use "signature", "v", "r", "s" arrays — always arrays, even for single values

Omit any field not used

Function Context:
"visibility": one of "public", "external", "internal", "private"
"stateMutability": one of "pure", "view", "payable", "nonpayable"
"accessControl": array of modifiers (e.g., ["onlyOwner", "whenNotPaused"])

Signature Inputs (actual signature data):
Use the following keys if relevant: "signature", "v", "r", "s"

Each is an array of objects with:

source: one of "parameter", "structField", "arrayElement", "mappingKey", "mappingValue"

solType: Solidity type (bytes, uint8, bytes32, etc.)

signerRole: optional (e.g., "user", "validator", "relayer", "owner", "guardian")

parentStruct: required if source is "structField"

arrayIndex: required if source is "arrayElement"

mappingKey: required if source is "mappingKey" or "mappingValue"

Signature Fields (the signed message structure):
"signatureFields":

structured: true if passed as a struct

structName: required if structured

fields: array of { name, solType, isNested, nestedStructName }

isNested: true if field is a nested struct

nestedStructName: required if isNested is true

Signature Control Fields (security-critical fields):
These are fields that may or may not appear in the contract. Return them only if found, otherwise omit:

"nonce": { name, solType, source, validationType }
"timestamp": { name, solType, source, validationType }
"deadline": { name, solType, source, validationType }
"chainId": { name, solType, source, validationType }
"version": { name, solType, source, validationType }
"domainSeparator": { name, solType, source, validationType }
"salt": { name, solType, source, validationType }

source: one of "parameter", "structField", "arrayElement", "stateVariable", "constant"
validationType: one of "explicit", "implicit", "none", "missing"

Security Analysis:
"securityChecks": {
  "replayProtection": boolean,
  "deadlineCheck": boolean,
  "nonceCheck": boolean,
  "chainIdCheck": boolean,
  "domainValidation": boolean,
  "signerValidation": boolean,
  "thresholdValidation": boolean
}

"vulnerabilities": array of detected issues:
  - "MISSING_NONCE": No nonce protection against replay attacks
  - "MISSING_DEADLINE": No deadline check, signature never expires
  - "MISSING_TIMESTAMP": No timestamp validation
  - "MISSING_CHAIN_ID": No chain ID validation, cross-chain replay possible
  - "MISSING_DOMAIN_SEPARATOR": No domain separator, cross-contract replay possible
  - "WEAK_SIGNER_VALIDATION": Insufficient signer validation
  - "NO_THRESHOLD_CHECK": Multi-sig without threshold validation
  - "UNSAFE_SIGNATURE_RECOVERY": Using ecrecover without validation
  - "MISSING_VERSION": EIP712 without version field
  - "INSUFFICIENT_ENTROPY": Weak randomness in signature scheme

"signatureComplexity": {
  "hasNestedStructs": boolean,
  "hasArrays": boolean,
  "hasMappings": boolean,
  "structDepth": number,
  "arrayLength": number,
  "totalFields": number
}

✅ Do not return nulls.
✅ Do not return explanations.
✅ Do not return comments.
✅ Only return valid JSON.
✅ Include all detected vulnerabilities in the vulnerabilities array.
✅ Be thorough in security analysis - missing protections are vulnerabilities.

Solidity input:

